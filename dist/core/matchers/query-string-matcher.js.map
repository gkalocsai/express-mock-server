{"version":3,"sources":["../../../lib/core/matchers/query-string-matcher.js"],"names":["TYPE_SPECIFIC_REGEX","isEqualQueryParamValues","masterValues","slaveValues","Array","isArray","length","sort","join","getMatchingResultByQueryStrings","masterQS","slaveQS","isMasterExist","JSON","stringify","isSlaveExist","MATCH_STRICT","MATCH_NO","MATCH_DEFAULT","result","countOfMatches","countOfMatchesUnspecific","forEach","name","values","type","isContained","indexOf","isSpecific","REG_ALL","value","regex","RegExp","test","masterQSLength","Object","keys","slaveQSLength","MatchingResult","MATCH_TYPE","SUBSET","getMatchesByQueryString","req","definitions","matches","record","query","queryStringParameters","isNo","push","MatchItem"],"mappings":"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","sourcesContent":["import MatchItem from './MatchItem';\r\nimport { REG_ALL } from '../../constants';\r\nimport MatchingResult, {\r\n  MATCH_DEFAULT,\r\n  MATCH_NO,\r\n  MATCH_STRICT,\r\n  MATCH_TYPE,\r\n} from './MatchingResult';\r\n\r\nconst TYPE_SPECIFIC_REGEX = 'SPECIFIC_REGEX';\r\n\r\nconst isEqualQueryParamValues = (masterValues, slaveValues) => {\r\n  if (!Array.isArray(masterValues) || !Array.isArray(slaveValues)) {\r\n    return false;\r\n  }\r\n\r\n  if (masterValues.length <= 1 || slaveValues.length <= 1) {\r\n    return false;\r\n  }\r\n\r\n  return [...masterValues].sort().join('') === [...slaveValues].sort().join('');\r\n};\r\n\r\n/**\r\n *                  exist     dont      exist     dont\r\n *  req/master        0         1         0         1\r\n *  bundle/slave      0         0         1         1\r\n *  result =          strict    default   no        subset/no\r\n *\r\n *  @param {Object} masterQS          request\r\n *  @param {Array.<Object>} slaveQS   bundle\r\n */\r\nexport const getMatchingResultByQueryStrings = (masterQS, slaveQS) => {\r\n  let isMasterExist = !!masterQS && JSON.stringify(masterQS) !== '{}';\r\n  let isSlaveExist = !!slaveQS;\r\n  // console.log('+++++++++++'.green);\r\n  // console.log(masterQS);\r\n  // console.log(slaveQS);\r\n  // console.log('+++++++++++'.blue);\r\n  if (!isMasterExist && !isSlaveExist) return MATCH_STRICT;\r\n  if (!isMasterExist && isSlaveExist) return MATCH_NO;\r\n  if (isMasterExist && !isSlaveExist) return MATCH_DEFAULT;\r\n  let result = null;\r\n  let countOfMatches = 0;\r\n  let countOfMatchesUnspecific = 0;\r\n  slaveQS.forEach(({ name, values, type }) => {\r\n    if (!masterQS[name]) {\r\n      result = MATCH_NO;\r\n    } else {\r\n      let isContained = values.indexOf(masterQS[name]) !== -1;\r\n\r\n      let isSpecific = values.indexOf(REG_ALL) === -1;\r\n      if (type === TYPE_SPECIFIC_REGEX) {\r\n        isSpecific = true;\r\n        if (!isContained) {\r\n          values.forEach((value) => {\r\n            let regex = new RegExp(value);\r\n\r\n            // console.log(name);\r\n            // console.log(regex);\r\n            // console.log(masterQS[name]);\r\n            // console.log('regex.test(masterQS[name]) ' +regex.test(masterQS[name]));\r\n            if (regex.test(masterQS[name])) {\r\n              isSpecific = false;\r\n            }\r\n          });\r\n        }\r\n      }\r\n\r\n      if (isSpecific && !isContained) {\r\n        if (isEqualQueryParamValues(masterQS[name], values)) {\r\n          countOfMatches++;\r\n        } else {\r\n          result = MATCH_NO;\r\n        }\r\n      } else {\r\n        if (!isSpecific) countOfMatchesUnspecific++;\r\n        countOfMatches++;\r\n      }\r\n    }\r\n  });\r\n\r\n  if (result !== null) return result;\r\n\r\n  let masterQSLength = Object.keys(masterQS).length;\r\n  let slaveQSLength = slaveQS.length;\r\n\r\n  if (slaveQSLength === countOfMatches && countOfMatches === masterQSLength)\r\n    return MATCH_STRICT;\r\n  return new MatchingResult(\r\n    MATCH_TYPE.SUBSET,\r\n    countOfMatches,\r\n    countOfMatchesUnspecific\r\n  );\r\n};\r\n\r\nexport const getMatchesByQueryString = (req, definitions) => {\r\n  let matches = [];\r\n  definitions.forEach((record) => {\r\n    // console.log(req.query);\r\n    // console.log(record.queryStringParameters);\r\n    let result = getMatchingResultByQueryStrings(\r\n      req.query,\r\n      record.queryStringParameters\r\n    );\r\n    // console.log('result');\r\n    // console.log(result);\r\n    if (!result.isNo()) {\r\n      matches.push(new MatchItem(record, result));\r\n    }\r\n  });\r\n  return matches;\r\n};\r\n"],"file":"query-string-matcher.js"}